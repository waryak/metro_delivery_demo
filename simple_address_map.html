<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Простая карта адресов</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }
        .main-container {
            display: flex;
            gap: 20px;
        }
        .map-container {
            flex: 1;
        }
        .sidebar {
            width: 350px;
            height: 600px;
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        svg {
            border: 1px solid #ccc;
            background-color: white;
        }
        .point {
            fill: red;
            cursor: pointer;
            transition: fill 0.2s;
        }
        .point:hover {
            fill: darkred;
            r: 5;
        }
        .circle {
            fill: rgba(255, 0, 0, 0.1);
            stroke: rgba(255, 0, 0, 0.5);
            stroke-width: 1;
            transition: all 0.3s ease;
        }
        .circle:hover {
            fill: rgba(255, 0, 0, 0.2);
            stroke: rgba(255, 0, 0, 0.8);
        }
        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            z-index: 1000;
            transform: translateX(-50%);
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .slider-container {
            display: flex;
            align-items: center;
        }
        .slider-container label {
            margin-right: 15px;
            font-weight: bold;
        }
        input[type="range"] {
            flex: 1;
            margin-right: 10px;
        }
        .value-display {
            min-width: 40px;
            text-align: center;
        }
        .address-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .address-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .address-header input[type="checkbox"] {
            margin-right: 10px;
        }
        .address-text {
            font-size: 14px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .individual-slider {
            margin-left: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }
        .individual-slider label {
            min-width: 55px;
            font-weight: normal;
        }
        .radius-value {
            min-width: 40px;
        }
        .hidden {
            display: none;
        }
        .map-info {
            margin-top: 10px;
            font-size: 14px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .weighted-avg {
            margin-left: 25px;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding: 3px 5px;
            background-color: #f0f0f0;
            border-radius: 3px;
            display: inline-block;
        }
        .select-all-container {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .select-all-container input[type="checkbox"] {
            margin-right: 10px;
        }
        .select-all-container label {
            margin-left: 10px;
            font-weight: bold;
        }
        .calculator-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .calculator-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .calculator-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .calculator-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .calculator-row label {
            font-weight: bold;
            flex: 1;
        }
        .calculator-row input {
            width: 120px;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .calculator-result {
            margin-top: 15px;
            padding: 10px;
            background-color: #e8f4f8;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .result-row:last-child {
            margin-bottom: 0;
            font-weight: bold;
            font-size: 1.1em;
            color: #2980b9;
        }
        .cost-breakdown {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 4px;
            font-size: 14px;
        }
        .breakdown-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .breakdown-row.total {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #ccc;
            font-weight: bold;
            color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="slider-container" style="display: none;">
            <label for="radius-multiplier">Global Radius Multiplier:</label>
            <input type="range" id="radius-multiplier" min="1" max="10" step="0.5" value="1">
            <span class="value-display" id="radius-value">1.0</span>
        </div>
    </div>
    
    <!-- Перемещаем карту с адресами в верхнюю часть страницы -->
    <div class="main-container">
        <div class="map-container">
            <svg id="map" width="800" height="600"></svg>
            <div id="tooltip"></div>
        </div>
        <div class="sidebar" id="address-list">
            <h3>Адреса</h3>
            <!-- Address items will be added dynamically here -->
        </div>
    </div>
    
    <!-- Калькуляторы доставки идут после карты -->
    <div class="calculator-container">
        <h3>Калькулятор доставки Яндекс</h3>
        <div class="calculator-form">
            <div class="calculator-row">
                <label for="delivery-type">Тип доставки:</label>
                <select id="delivery-type">
                    <option value="standard">Стандартная</option>
                    <option value="two-points">2 точки Б</option>
                    <option value="three-points">3 точки Б</option>
                    <option value="four-points">4 точки Б</option>
                </select>
            </div>
            <div class="calculator-row">
                <label for="multiplier">Повышающий коэффициент:</label>
                <input type="number" id="multiplier" min="1" step="0.1" value="1.0">
            </div>
            <div class="calculator-row" id="radius-row" style="display: none;">
                <label>Используемый радиус R:</label>
                <span id="radius-r-display">0.0 км</span>
            </div>
            <div class="calculator-result">
                <div class="result-row">
                    <span>Среднее расстояние:</span>
                    <span id="avg-distance">0.0 км</span>
                </div>
                <div class="result-row">
                    <span>Стоимость доставки:</span>
                    <span id="delivery-cost">0 ₽</span>
                </div>
            </div>
        </div>
    </div>

    <div class="calculator-container magnit-calculator">
        <h3>Калькулятор доставки Магнит</h3>
        <div class="calculator-form">
            <div class="calculator-row">
                <label for="magnit-weight">Вес доставки (кг):</label>
                <input type="number" id="magnit-weight" min="0" step="0.1" value="10">
            </div>
            <div class="calculator-row">
                <label for="magnit-multiplier">Повышающий коэффициент:</label>
                <input type="number" id="magnit-multiplier" min="1" step="0.1" value="1.0">
            </div>
            <div class="calculator-result">
                <div class="result-row">
                    <span>Среднее расстояние:</span>
                    <span id="magnit-avg-distance">0.0 км</span>
                </div>
                <div class="result-row">
                    <span>Стоимость доставки:</span>
                    <span id="magnit-delivery-cost">0 ₽</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Данные адресов
        const addressData = {
            "115088. Москва, ул. 1-я Дубровская, д. 13А, стр. 1": {
                "lat": 55.722801,
                "lng": 37.674993
            },
            "127018. Москва, ул. Складочная, д.1, стр. 1": {
                "lat": 55.800453,
                "lng": 37.594584
            },
            "109548, Москва, ул. Шоссейная, д. 2Б": {
                "lat": 55.700679,
                "lng": 37.726331
            },
            "129226, Москва, пр-т Мира, д. 211, стр. 1": {
                "lat": 55.844015,
                "lng": 37.662785
            },
            "117545. Москва, ул. Дорожная, д. 1, корп. 1": {
                "lat": 55.630721,
                "lng": 37.62493
            },
            "121471. Москва, ул. Рябиновая, д. 59": {
                "lat": 55.685878,
                "lng": 37.431828
            },
            "123458. Москва, ул. Маршала Прошлякова, д. 14": {
                "lat": 55.791187,
                "lng": 37.388718
            },
            "105523, Москва, 104 км МКАД, д. 6": {
                "lat": 55.811235,
                "lng": 37.837201
            },
            "125445. Москва, Ленинградское шоссе, д. 71Г": {
                "lat": 55.875784,
                "lng": 37.447288
            },
            "140053, МО, г. Котельники, Новорязанское шоссе, д .5": {
                "lat": 55.668376,
                "lng": 37.865813
            },
            "127204. Москва, Дмитровское шоссе, д. 165Б": {
                "lat": 55.946426,
                "lng": 37.541314
            },
            "119634. Москва, Боровское шоссе, д. 10А": {
                "lat": 55.653873,
                "lng": 37.375701
            },
            "108811 г. Москва, п. Московский, кв-л 34, д. 3, стр. 1": {
                "lat": 55.620042,
                "lng": 37.387424
            },
            "140073. МО, Люберецкий р-н, 23 км Новорязанского ш., уч. 17": {
                "lat": 55.655386,
                "lng": 37.906722
            },
            "142715, МО, Ленинский район, пос. Совхоза им. Ленина, владение 8": {
                "lat": 55.574981,
                "lng": 37.754952
            },
            "143987. МО, г. Балашиха, мкр. Железнодорожный, ул. Советская, д. 60": {
                "lat": 55.750094,
                "lng": 38.046087
            },
            "141733. МО, г. Лобня, ул. Горки Киовские, вл. 15": {
                "lat": 56.02926,
                "lng": 37.46114
            },
            "141580, МО, Солнечногорский район, д. Черная грязь, ул. Торгово-Промышленная, д. 5": {
                "lat": 56.041737,
                "lng": 36.851642
            },
            "143020. МО, Одинцовский район, 35 км Минского ш., д. 2": {
                "lat": 55.624932,
                "lng": 37.144259
            },
            "142181, МО, 42 км Симферопольского ш., д. 1. стр.1": {
                "lat": 55.393165,
                "lng": 37.601627
            },
            "142434. МО, Ногинский район, д. Новые Псарьки, ул. Парковая, д. 4": {
                "lat": 55.831443,
                "lng": 38.368753
            },
            "214006, МО, Серпухов, б-р 65 лет Победы, д. 4": {
                "lat": 54.94413,
                "lng": 37.403127
            }
        };

        // Находим минимальные и максимальные значения координат
        let minLat = Infinity, maxLat = -Infinity;
        let minLng = Infinity, maxLng = -Infinity;

        for (const address in addressData) {
            const { lat, lng } = addressData[address];
            minLat = Math.min(minLat, lat);
            maxLat = Math.max(maxLat, lat);
            minLng = Math.min(minLng, lng);
            maxLng = Math.max(maxLng, lng);
        }

        // Добавляем небольшой отступ
        const padding = 0.05;
        const latRange = maxLat - minLat;
        const lngRange = maxLng - minLng;
        
        minLat -= latRange * padding;
        maxLat += latRange * padding;
        minLng -= lngRange * padding;
        maxLng += lngRange * padding;

        // Получаем SVG элемент
        const svg = document.getElementById('map');
        const svgWidth = parseInt(svg.getAttribute('width'));
        const svgHeight = parseInt(svg.getAttribute('height'));
        
        // Функция для преобразования координат в пиксели
        function latLngToPixel(lat, lng) {
            const x = ((lng - minLng) / (maxLng - minLng)) * svgWidth;
            const y = svgHeight - ((lat - minLat) / (maxLat - minLat)) * svgHeight;
            return { x, y };
        }

        // Преобразование точек в пиксели
        const points = [];
        for (const address in addressData) {
            const { lat, lng } = addressData[address];
            const { x, y } = latLngToPixel(lat, lng);
            
            points.push({
                address,
                x,
                y,
                lat,
                lng,
                radius: 0, // Will be calculated later
                baseRadiusKm: 0, // Base radius in kilometers
                radiusMultiplier: 5, // Initial radius value (instead of multiplier)
                visible: true, // Point visibility
                weight: 1 // Default weight value
            });
        }

        // Функция для расчета расстояния между двумя точками на карте в пикселях
        function calculatePixelDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        
        // Функция для расчета расстояния между двумя географическими точками в километрах (формула Гаверсинуса)
        function calculateGeoDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Радиус Земли в километрах
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Расчет оптимального радиуса для каждой точки
        points.forEach(point => {
            // Находим ближайшую точку
            let minDistance = Infinity;
            let minDistanceKm = Infinity;
            
            points.forEach(otherPoint => {
                if (point !== otherPoint) {
                    // Рассчитываем расстояние в пикселях для отображения
                    const distance = calculatePixelDistance(point, otherPoint);
                    minDistance = Math.min(minDistance, distance);
                    
                    // Рассчитываем расстояние в километрах для информации
                    const distanceKm = calculateGeoDistance(
                        point.lat, point.lng, 
                        otherPoint.lat, otherPoint.lng
                    );
                    minDistanceKm = Math.min(minDistanceKm, distanceKm);
                }
            });
            
            // Устанавливаем радиус равным половине расстояния до ближайшей точки,
            // чтобы круги касались друг друга
            point.radius = minDistance * 0.5; 
            point.baseRadiusKm = minDistanceKm * 0.5; // Реальный радиус в километрах
        });

        // Отображаем точки и круги на карте
        const circles = [];
        const centerPoints = [];
        
        points.forEach((point, index) => {
            // Создаем круг
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', point.radius);
            circle.setAttribute('class', 'circle');
            circle.setAttribute('data-address', point.address);
            circle.setAttribute('data-index', index);
            
            // Добавляем обработчики событий
            circle.addEventListener('mouseover', showTooltip);
            circle.addEventListener('mouseout', hideTooltip);
            circle.addEventListener('mousemove', moveTooltip);
            
            svg.appendChild(circle);
            circles.push(circle);
            
            // Создаем центральную точку
            const centerPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerPoint.setAttribute('cx', point.x);
            centerPoint.setAttribute('cy', point.y);
            centerPoint.setAttribute('r', 3);
            centerPoint.setAttribute('class', 'point');
            centerPoint.setAttribute('data-address', point.address);
            
            // Добавляем обработчики событий
            centerPoint.addEventListener('mouseover', showPointTooltip);
            centerPoint.addEventListener('mouseout', hideTooltip);
            centerPoint.addEventListener('mousemove', moveTooltip);
            
            svg.appendChild(centerPoint);
            centerPoints.push(centerPoint);
        });
        
        // Получаем элемент всплывающей подсказки
        const tooltip = document.getElementById('tooltip');
        
        // Функция для отображения всплывающей подсказки для точки
        function showPointTooltip(event) {
            const address = this.getAttribute('data-address');
            tooltip.textContent = address;
            tooltip.style.opacity = '1';
            moveTooltip.call(this, event);
        }
        
        // Функция для отображения всплывающей подсказки для круга
        function showTooltip(e) {
            const circle = e.target;
            const index = parseInt(circle.getAttribute('data-index'));
            const point = points[index];
            const radius = parseFloat(circle.getAttribute('data-radius')); // Get the actual radius in km
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${point.address}</strong><br>
                Радиус: ${radius.toFixed(1)} км
            `;
            
            // Position the tooltip just 10px above the cursor
            const rect = svg.getBoundingClientRect();
            tooltip.style.left = `${e.clientX}px`;
            tooltip.style.top = `${e.clientY - 10}px`; // Just 10px above cursor
            tooltip.style.opacity = '1';
            
            // Highlight the corresponding address in the sidebar
            highlightAddressInSidebar(point.address);
        }
        
        // Функция для скрытия всплывающей подсказки
        function hideTooltip() {
            tooltip.style.opacity = '0';
        }
        
        // Функция для перемещения всплывающей подсказки
        function moveTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = `${event.clientX}px`;
            tooltip.style.top = `${event.clientY - 10}px`; // Just 10px above cursor
        }
        
        // Выделение адреса в списке при наведении на точку
        function highlightAddressInSidebar(address) {
            // Remove highlight from all items
            const allItems = document.querySelectorAll('.address-item');
            allItems.forEach(item => {
                item.style.backgroundColor = '';
                item.classList.remove('highlight-active');
            });
            
            // Find the address item with matching text and highlight it
            const addressItems = document.querySelectorAll('.address-text');
            let foundItem = null;
            
            addressItems.forEach(item => {
                if (item.textContent === address) {
                    // Get the parent address-item
                    const addressItem = item.closest('.address-item');
                    foundItem = addressItem;
                    
                    // Apply highlight
                    addressItem.style.backgroundColor = '#e3f2fd';
                    addressItem.classList.add('highlight-active');
                }
            });
            
            // If we found the item, scroll to center it in the sidebar
            if (foundItem) {
                const sidebar = document.getElementById('address-list');
                
                // Calculate the position to center the item in the viewport
                const sidebarHeight = sidebar.clientHeight;
                const itemHeight = foundItem.offsetHeight;
                const itemTop = foundItem.offsetTop;
                
                // Center the item in the viewport with precise calculation
                sidebar.scrollTop = itemTop - (sidebarHeight / 2) + (itemHeight / 2);
                
                // Ensure the item is fully visible by checking boundaries
                const itemBottom = itemTop + itemHeight;
                const scrollBottom = sidebar.scrollTop + sidebarHeight;
                
                if (itemTop < sidebar.scrollTop) {
                    // If item is above visible area, scroll up to show it
                    sidebar.scrollTop = itemTop;
                } else if (itemBottom > scrollBottom) {
                    // If item is below visible area, scroll down to show it
                    sidebar.scrollTop = itemBottom - sidebarHeight;
                }
            }
        }
        
        // Создаем список адресов с элементами управления
        const addressList = document.getElementById('address-list');
        
        points.forEach((point, index) => {
            const addressItem = document.createElement('div');
            addressItem.className = 'address-item';
            
            // Создаем заголовок с чекбоксом
            const header = document.createElement('div');
            header.className = 'address-header';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = point.visible;
            checkbox.dataset.index = index;
            
            checkbox.addEventListener('change', function() {
                const idx = parseInt(this.dataset.index);
                points[idx].visible = this.checked;
                
                // Обновляем видимость элементов
                updateElementVisibility(idx);
            });
            
            const addressText = document.createElement('div');
            addressText.className = 'address-text';
            addressText.textContent = point.address;
            
            header.appendChild(checkbox);
            header.appendChild(addressText);
            addressItem.appendChild(header);
            
            // Создаем индивидуальный слайдер для радиуса
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'individual-slider';
            
            const sliderLabel = document.createElement('label');
            sliderLabel.textContent = 'Radius (km):';
            
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = '1';
            slider.max = '50';
            slider.step = '1';
            slider.value = point.radiusMultiplier;
            slider.dataset.index = index;
            
            const radiusValue = document.createElement('span');
            radiusValue.className = 'radius-value';
            radiusValue.textContent = point.radiusMultiplier.toFixed(1);
            
            slider.addEventListener('input', function() {
                const idx = parseInt(this.dataset.index);
                const radiusValue = parseFloat(this.value);
                this.nextElementSibling.textContent = radiusValue.toFixed(1);
                
                // Update the radius directly
                points[idx].radiusMultiplier = radiusValue;
                
                // Update the radius display
                updateRadius(idx);
                
                // Ensure metrics are updated (this is redundant but added for safety)
                updateAllWeightedAverages();
            });
            
            sliderContainer.appendChild(sliderLabel);
            sliderContainer.appendChild(slider);
            sliderContainer.appendChild(radiusValue);
            addressItem.appendChild(sliderContainer);
            
            // Добавляем элемент для веса
            const weightContainer = document.createElement('div');
            weightContainer.className = 'individual-slider';
            weightContainer.style.marginTop = '8px';

            const weightLabel = document.createElement('label');
            weightLabel.textContent = 'Weight:';

            const weightInput = document.createElement('input');
            weightInput.type = 'number';
            weightInput.min = '1';
            weightInput.max = '100';
            weightInput.step = '1';
            weightInput.value = point.weight;
            weightInput.dataset.index = index;
            weightInput.style.width = '50px';

            weightInput.addEventListener('change', function() {
                const idx = parseInt(this.dataset.index);
                const weightValue = parseInt(this.value);
                
                // Ensure weight is at least 1
                if (weightValue < 1) {
                    this.value = '1';
                    points[idx].weight = 1;
                } else {
                    points[idx].weight = weightValue;
                }
                
                // Update the weighted averages
                updateAllWeightedAverages();
            });

            weightContainer.appendChild(weightLabel);
            weightContainer.appendChild(weightInput);
            addressItem.appendChild(weightContainer);
            
            // Добавляем элемент в список
            addressList.appendChild(addressItem);
        });
        
        // Функция для обновления видимости элементов
        function updateElementVisibility(index) {
            const point = points[index];
            const circle = circles[index];
            const centerPoint = centerPoints[index];
            
            if (point.visible) {
                circle.classList.remove('hidden');
                centerPoint.classList.remove('hidden');
            } else {
                circle.classList.add('hidden');
                centerPoint.classList.add('hidden');
            }
            
            // Обновляем информацию о карте
            updateMapInfo();
            
            // Обновляем все средневзвешенные значения, так как изменение видимости
            // влияет на средневзвешенные значения всех точек
            updateAllWeightedAverages();
        }
        
        // Функция для обновления радиуса
        function updateRadius(index) {
            const point = points[index];
            const circle = circles[index];
            
            // Use the radius value directly from the slider
            const radiusKm = point.radiusMultiplier;
            
            // Calculate the pixel radius based on the km radius
            const pixelRadius = kmToPixels(radiusKm);
            
            // Update the circle element
            circle.setAttribute('r', pixelRadius);
            circle.setAttribute('data-radius', radiusKm); // Store the actual radius in km
            circle.setAttribute('data-index', index);
            
            // Make sure we update all weighted averages
            updateAllWeightedAverages();
        }
        
        // Add a helper function to convert km to pixels
        function kmToPixels(kmRadius) {
            // Get map dimensions
            const mapInfo = calculateMapDimensions();
            const svgWidth = parseInt(svg.getAttribute('width'));
            
            // Calculate the pixel-to-km ratio
            const pixelsPerKm = svgWidth / mapInfo.width;
            
            // Convert km to pixels
            return kmRadius * pixelsPerKm;
        }
        
        // Добавляем расчет центральной точки карты и размеры в километрах
        function calculateMapDimensions() {
            // Находим границы карты (учитывая только видимые точки)
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            let sumLat = 0, sumLng = 0;
            let visiblePoints = 0;
            
            points.forEach(point => {
                if (point.visible) {
                    minLat = Math.min(minLat, point.lat);
                    maxLat = Math.max(maxLat, point.lat);
                    minLng = Math.min(minLng, point.lng);
                    maxLng = Math.max(maxLng, point.lng);
                    
                    sumLat += point.lat;
                    sumLng += point.lng;
                    visiblePoints++;
                }
            });
            
            // Рассчитываем центральную точку (среднее значение координат)
            const centerLat = visiblePoints > 0 ? sumLat / visiblePoints : 0;
            const centerLng = visiblePoints > 0 ? sumLng / visiblePoints : 0;
            
            // Рассчитываем ширину и высоту карты в километрах
            const width = calculateGeoDistance(minLat, minLng, minLat, maxLng);
            const height = calculateGeoDistance(minLat, minLng, maxLat, minLng);
            
            return {
                center: { lat: centerLat, lng: centerLng },
                width: width,
                height: height,
                bounds: { minLat, maxLat, minLng, maxLng }
            };
        }
        
        // Функция для обновления информации о карте
        function updateMapInfo() {
            const mapInfo = calculateMapDimensions();
            
            // Обновляем информацию в интерфейсе
            const mapInfoElement = document.getElementById('map-info');
            mapInfoElement.innerHTML = `
                <strong>Карта:</strong> ${mapInfo.width.toFixed(1)} км × ${mapInfo.height.toFixed(1)} км<br>
                <strong>Центр:</strong> ${mapInfo.center.lat.toFixed(5)}, ${mapInfo.center.lng.toFixed(5)}
            `;
        }

        // Добавляем элемент для отображения информации о карте
        const controlsDiv = document.querySelector('.controls');
        const mapInfoDiv = document.createElement('div');
        mapInfoDiv.id = 'map-info';
        mapInfoDiv.className = 'map-info';
        controlsDiv.appendChild(mapInfoDiv);

        // Add a new div for delivery distance statistics
        const deliveryStatsDiv = document.createElement('div');
        deliveryStatsDiv.id = 'delivery-stats';
        deliveryStatsDiv.className = 'map-info';
        deliveryStatsDiv.style.marginTop = '10px';
        controlsDiv.appendChild(deliveryStatsDiv);

        // Функция для расчета взвешенного среднего радиуса
        function calculateWeightedAverageRadius(pointIndex) {
            const point = points[pointIndex];
            let weightSum = 0;
            let radiusSum = 0;
            
            // Consider only visible points
            points.forEach((otherPoint, otherIndex) => {
                if (!otherPoint.visible || pointIndex === otherIndex) return;
                
                // Calculate distance between points in kilometers
                const distance = calculateGeoDistance(
                    point.lat, point.lng, 
                    otherPoint.lat, otherPoint.lng
                );
                
                // Avoid division by zero, set minimum distance
                const effectiveDistance = Math.max(distance, 0.1);
                
                // Use the weight of the other point as a coefficient
                const weight = otherPoint.weight / effectiveDistance;
                
                // Get the current radius of the other point - use direct radius value
                const otherRadius = otherPoint.radiusMultiplier; // Use direct radius value
                
                weightSum += weight;
                radiusSum += otherRadius * weight;
            });
            
            // If there are no other visible points, return own radius
            if (weightSum === 0) {
                return point.radiusMultiplier; // Use direct radius value
            }
            
            // Otherwise return weighted average
            return radiusSum / weightSum;
        }
        
        // Функция для обновления всех взвешенных средних радиусов
        function updateAllWeightedAverages() {
            let totalDeliveryDistance = 0;
            let weightedDeliveryDistanceSum = 0;
            let visiblePointsCount = 0;
            let totalWeight = 0;
            
            // Update for all points
            points.forEach((point, index) => {
                if (!point.visible) return;
                
                const weightedAvg = calculateWeightedAverageRadius(index);
                // Calculate average delivery distance - CHANGED: removed 2/3 coefficient
                const avgDeliveryDistance = weightedAvg; // Previously: (2 * weightedAvg) / 3
                
                // Add to total for unweighted sum
                totalDeliveryDistance += avgDeliveryDistance;
                
                // Add to weighted sum for weighted average
                weightedDeliveryDistanceSum += avgDeliveryDistance * point.weight;
                totalWeight += point.weight;
                
                visiblePointsCount++;
            });
            
            // Calculate unweighted average across all visible points
            const averageDeliveryDistance = visiblePointsCount > 0 ? totalDeliveryDistance / visiblePointsCount : 0;
            
            // Calculate weighted average
            const weightedAverageDeliveryDistance = totalWeight > 0 ? weightedDeliveryDistanceSum / totalWeight : 0;
            
            // Update the delivery stats display - REMOVED "Среднее по всем адресам"
            deliveryStatsDiv.innerHTML = `
                <strong>Статистика доставки:</strong><br>
                Взвешенное средняя дистанция: ${averageDeliveryDistance.toFixed(1)} км
                
                <div class="reference-text">
                    <h4 style="margin-top: 10px; margin-bottom: 5px;">Модель строилась на основании:</h4>
                    <ol style="margin: 0; padding-left: 20px;">
                        <li>Средняя дистанция доставки внутри зоны с радиусом R = R</li>
                        <li>Среднее расстояние между 2мя случайными точками внутри зоны = 0.9R</li>
                        <li>Средний никратчайший путь проходящий через 3 точки в зоне с радиусом R равен 1.5R</li>
                        <li>Средний никратчайший путь проходящий через 4 точки в зоне с радиусом R равен 1.6R</li>
                    </ol>
                </div>
            `;
            
            // Сохраняем значения в глобальных переменных для использования в калькуляторах
            window.averageDeliveryDistance = averageDeliveryDistance;
            window.weightedAverageDeliveryDistance = weightedAverageDeliveryDistance;
        }

        // Вызываем функцию обновления при загрузке страницы
        updateAllWeightedAverages();

        // Add this right after the <h3>Адреса</h3> in the sidebar
        const sidebar = document.getElementById('address-list');
        const addressesHeader = sidebar.querySelector('h3');

        // Create a container for the "Select All" checkbox
        const selectAllContainer = document.createElement('div');
        selectAllContainer.className = 'select-all-container';
        selectAllContainer.style.marginBottom = '15px';
        selectAllContainer.style.display = 'flex';
        selectAllContainer.style.alignItems = 'center';

        // Create the "Select All" checkbox
        const selectAllCheckbox = document.createElement('input');
        selectAllCheckbox.type = 'checkbox';
        selectAllCheckbox.id = 'select-all';
        selectAllCheckbox.checked = true; // Initially all addresses are visible

        // Create label for the checkbox
        const selectAllLabel = document.createElement('label');
        selectAllLabel.htmlFor = 'select-all';
        selectAllLabel.textContent = 'Выбрать все';
        selectAllLabel.style.marginLeft = '10px';
        selectAllLabel.style.fontWeight = 'bold';

        // Add event listener to toggle all checkboxes
        selectAllCheckbox.addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Update all address checkboxes
            const checkboxes = document.querySelectorAll('.address-header input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
                
                // Trigger the change event for each checkbox
                const changeEvent = new Event('change');
                checkbox.dispatchEvent(changeEvent);
            });
        });

        // Append elements to the container
        selectAllContainer.appendChild(selectAllCheckbox);
        selectAllContainer.appendChild(selectAllLabel);

        // Insert the container after the header
        addressesHeader.insertAdjacentElement('afterend', selectAllContainer);

        // Modify the existing checkbox change event to update the "Select All" checkbox
        // Add this to the existing checkbox event listener
        document.addEventListener('change', function(e) {
            if (e.target.matches('.address-header input[type="checkbox"]')) {
                // Check if all checkboxes are checked
                const allCheckboxes = document.querySelectorAll('.address-header input[type="checkbox"]');
                const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
                
                // Update the "Select All" checkbox without triggering its change event
                selectAllCheckbox.checked = allChecked;
            }
        });

        // Function to update the delivery calculator
        function updateDeliveryCalculator() {
            // Get the delivery type
            const deliveryType = document.getElementById('delivery-type').value;
            
            // Используем сохраненное значение взвешенного среднего расстояния
            let averageDistance = window.averageDeliveryDistance || 0;
            
            // Calculate the effective distance based on delivery type
            let effectiveDistance = averageDistance;
            let radiusRValue = 0;
            let additionalFee = 0;
            
            if (deliveryType === 'two-points') {
                // For "2 точки Б", use the formula (R + 0.9*R)
                radiusRValue = averageDistance;
                effectiveDistance = radiusRValue + (0.9 * radiusRValue);
                additionalFee = 95; // Additional fee for 2 points
            } else if (deliveryType === 'three-points') {
                // For "3 точки Б", use the formula (R + 1.5*R)
                radiusRValue = averageDistance;
                effectiveDistance = radiusRValue + (1.5 * radiusRValue);
                additionalFee = 190; // Additional fee for 3 points
            } else if (deliveryType === 'four-points') {
                // For "4 точки Б", use the formula (R + 1.6*R)
                radiusRValue = averageDistance;
                effectiveDistance = radiusRValue + (1.6 * radiusRValue);
                additionalFee = 285; // Additional fee for 4 points
            }
            
            // Update the radius R display
            if (deliveryType !== 'standard') {
                const radiusRDisplay = document.getElementById('radius-r-display');
                if (radiusRDisplay) {
                    radiusRDisplay.textContent = `${radiusRValue.toFixed(1)} км`;
                }
                // Show the radius row
                const radiusRow = document.getElementById('radius-row');
                if (radiusRow) {
                    radiusRow.style.display = 'flex';
                }
            } else {
                // Hide the radius row for standard delivery
                const radiusRow = document.getElementById('radius-row');
                if (radiusRow) {
                    radiusRow.style.display = 'none';
                }
            }
            
            // Get multiplier input
            const multiplier = parseFloat(document.getElementById('multiplier').value) || 1;
            
            // Calculate delivery cost using the formula: 135 + 8*D + 30*D + additionalFee
            const D = effectiveDistance;
            const baseCost = 135;
            const distanceCost = 8 * D;
            const timeCost = 30 * D;
            const deliveryCost = (baseCost + distanceCost + timeCost + additionalFee) * multiplier;
            
            // Update the display
            document.getElementById('avg-distance').textContent = `${effectiveDistance.toFixed(1)} км`;
            document.getElementById('delivery-cost').textContent = `${Math.round(deliveryCost)} ₽`;

            // Add cost breakdown
            const breakdownElement = document.getElementById('cost-breakdown') || document.createElement('div');
            breakdownElement.id = 'cost-breakdown';
            breakdownElement.className = 'cost-breakdown';
            breakdownElement.innerHTML = `
                <div class="breakdown-row"><span>Базовая стоимость:</span><span>${baseCost} ₽</span></div>
                <div class="breakdown-row"><span>Стоимость расстояния (8 × ${D.toFixed(1)} км):</span><span>${Math.round(distanceCost)} ₽</span></div>
                <div class="breakdown-row"><span>Стоимость времени (30 × ${D.toFixed(1)} км):</span><span>${Math.round(timeCost)} ₽</span></div>
                ${additionalFee > 0 ? `<div class="breakdown-row"><span>Доп. плата за точки:</span><span>${additionalFee} ₽</span></div>` : ''}
                ${multiplier !== 1 ? `<div class="breakdown-row"><span>Коэффициент:</span><span>×${multiplier.toFixed(1)}</span></div>` : ''}
                <div class="breakdown-row total"><span>Итого:</span><span>${Math.round(deliveryCost)} ₽</span></div>
            `;

            // Add the breakdown to the result section if it doesn't exist
            const resultElement = document.querySelector('.calculator-result');
            if (!document.getElementById('cost-breakdown')) {
                resultElement.appendChild(breakdownElement);
            }
        }

        // Add event listeners to calculator inputs
        document.addEventListener('DOMContentLoaded', function() {
            const calculatorInputs = ['multiplier', 'delivery-type'];
            
            calculatorInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', updateDeliveryCalculator);
                    if (inputId === 'delivery-type') {
                        input.addEventListener('change', function() {
                            // Show/hide the radius display based on delivery type
                            const radiusRow = document.getElementById('radius-row');
                            if (this.value === 'standard') {
                                radiusRow.style.display = 'none';
                            } else {
                                radiusRow.style.display = 'flex';
                            }
                            updateDeliveryCalculator();
                        });
                    }
                }
            });
            
            // Also update when the weighted averages are updated
            const originalUpdateAllWeightedAverages = updateAllWeightedAverages;
            updateAllWeightedAverages = function() {
                originalUpdateAllWeightedAverages.apply(this, arguments);
                updateDeliveryCalculator();
            };
            
            // Initial update
            updateDeliveryCalculator();
        });

        // Function to update the Magnit delivery calculator
        function updateMagnitCalculator() {
            // Используем сохраненное значение взвешенного среднего расстояния
            let averageDistance = window.averageDeliveryDistance || 0;
            
            // Use the weighted average distance directly
            const effectiveDistance = averageDistance;
            
            // Get weight and multiplier inputs
            const weight = parseFloat(document.getElementById('magnit-weight').value) || 10;
            const multiplier = parseFloat(document.getElementById('magnit-multiplier').value) || 1;
            
            // Calculate delivery cost using the formula: 365 + 27.5*R + 11*(вес - 10)
            const R = effectiveDistance;
            const baseCost = 365;
            const distanceCost = 27.5 * R;
            const weightCost = Math.max(0, 11 * (weight - 10)); // Only charge for weight above 10kg
            
            const deliveryCost = (baseCost + distanceCost + weightCost) * multiplier;
            
            // Update the display
            document.getElementById('magnit-avg-distance').textContent = `${effectiveDistance.toFixed(1)} км`;
            document.getElementById('magnit-delivery-cost').textContent = `${Math.round(deliveryCost)} ₽`;

            // Add cost breakdown
            const breakdownElement = document.getElementById('magnit-cost-breakdown') || document.createElement('div');
            breakdownElement.id = 'magnit-cost-breakdown';
            breakdownElement.className = 'cost-breakdown';
            breakdownElement.innerHTML = `
                <div class="breakdown-row"><span>Базовая стоимость:</span><span>${baseCost} ₽</span></div>
                <div class="breakdown-row"><span>Стоимость расстояния (27.5 × ${R.toFixed(1)} км):</span><span>${Math.round(distanceCost)} ₽</span></div>
                ${weight > 10 ? `<div class="breakdown-row"><span>Доплата за вес (11 × ${(weight - 10).toFixed(1)} кг):</span><span>${Math.round(weightCost)} ₽</span></div>` : ''}
                ${multiplier !== 1 ? `<div class="breakdown-row"><span>Коэффициент:</span><span>×${multiplier.toFixed(1)}</span></div>` : ''}
                <div class="breakdown-row total"><span>Итого:</span><span>${Math.round(deliveryCost)} ₽</span></div>
            `;

            // Add the breakdown to the result section if it doesn't exist
            const resultElement = document.querySelector('.magnit-calculator .calculator-result');
            if (!document.getElementById('magnit-cost-breakdown')) {
                resultElement.appendChild(breakdownElement);
            }
        }

        // Add event listeners to calculator inputs
        document.addEventListener('DOMContentLoaded', function() {
            // Existing code for Yandex calculator
            const calculatorInputs = ['multiplier', 'delivery-type'];
            
            calculatorInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', updateDeliveryCalculator);
                    if (inputId === 'delivery-type') {
                        input.addEventListener('change', function() {
                            // Show/hide the radius display based on delivery type
                            const radiusRow = document.getElementById('radius-row');
                            if (this.value === 'standard') {
                                radiusRow.style.display = 'none';
                            } else {
                                radiusRow.style.display = 'flex';
                            }
                            updateDeliveryCalculator();
                        });
                    }
                }
            });
            
            // New event listeners for Magnit calculator
            const magnitInputs = ['magnit-multiplier', 'magnit-weight'];
            magnitInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', updateMagnitCalculator);
                }
            });
            
            // Also update both calculators when the weighted averages are updated
            const originalUpdateAllWeightedAverages = updateAllWeightedAverages;
            updateAllWeightedAverages = function() {
                originalUpdateAllWeightedAverages.apply(this, arguments);
                updateDeliveryCalculator();
                updateMagnitCalculator();
            };
            
            // Initial updates
            updateDeliveryCalculator();
            updateMagnitCalculator();
        });

        // Перевод интерфейса на русский язык
        // Обновляем заголовки и тексты
        document.addEventListener('DOMContentLoaded', function() {
            // Перевод заголовка списка адресов
            const addressHeader = document.querySelector('#address-list h3');
            if (addressHeader) {
                addressHeader.textContent = 'Адреса';
            }
            
            // Перевод чекбокса "Select All"
            const selectAllLabel = document.querySelector('.select-all-container label');
            if (selectAllLabel) {
                selectAllLabel.textContent = 'Выбрать все';
            }
            
            // Обновляем тексты в калькуляторах
            document.getElementById('delivery-type').querySelectorAll('option').forEach(option => {
                if (option.value === 'standard') option.textContent = 'Стандартная';
                if (option.value === 'two-points') option.textContent = '2 точки Б';
                if (option.value === 'three-points') option.textContent = '3 точки Б';
                if (option.value === 'four-points') option.textContent = '4 точки Б';
            });
            
            // Обновляем подписи полей
            const labels = document.querySelectorAll('label');
            labels.forEach(label => {
                if (label.htmlFor === 'multiplier') label.textContent = 'Повышающий коэффициент:';
                if (label.htmlFor === 'magnit-weight') label.textContent = 'Вес доставки (кг):';
                if (label.htmlFor === 'magnit-multiplier') label.textContent = 'Повышающий коэффициент:';
                if (label.htmlFor === 'delivery-type') label.textContent = 'Тип доставки:';
            });
            
            // Обновляем тексты в результатах
            const resultLabels = document.querySelectorAll('.result-row span:first-child');
            resultLabels.forEach(span => {
                if (span.textContent === 'Average distance:') span.textContent = 'Среднее расстояние:';
                if (span.textContent === 'Delivery cost:') span.textContent = 'Стоимость доставки:';
            });
        });
    </script>
</body>
</html> 